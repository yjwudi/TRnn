<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - convex geometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="static/three-js/build/three.js"></script>
		<script src="static/three-js/examples/js/controls/OrbitControls.js"></script>
		<script src="static/three-js/examples/js/controls/TrackballControls.js"></script>
		<script src="static/three-js/examples/js/QuickHull.js"></script>
		<script src="static/three-js/examples/js/geometries/ConvexGeometry.js"></script>
		<script src="static/three-js/examples/js/Detector.js"></script>
		<script src="static/three-js/examples/js/libs/stats.min.js"></script>
		<script>

			if ( ! Detector.webgl )
				Detector.addGetWebGLMessage();

			var group, camera, scene, renderer, cluster_id_array;
			var agent_pos_array = new Array();
			var agent_line_array = new Array();

			function threeStart()
			{
				init();
				animate();
			}

			function init()
			{

				scene = new THREE.Scene();

				width = document.getElementById('canvas3d').clientWidth;
				height = document.getElementById('canvas3d').clientHeight;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				// renderer.setClearColor('rgb(135,206,250)',1.0);  
				// renderer.setClearColor(0xff0000,1.0);
				document.getElementById('canvas3d').appendChild( renderer.domElement );

				// camera

				camera = new THREE.PerspectiveCamera( 80, width / height, 1, 100000 );
				// camera.position.set( 15, 20, 30 );
				// camera.lookAt(0,0,0);
				camera.position.set(0, 0, -300);
				camera.lookAt(10, 10, 0);
				scene.add( camera );

				// controls

				// var controls = new THREE.OrbitControls( camera, renderer.domElement );
				// controls.minDistance = 20;//控制滚轮放大画面最多能放大到多大
				// controls.maxDistance = 5000;//控制滚轮缩小画面最多能缩小到多小
				// controls.maxPolarAngle = Math.PI;//左键通过拖拽，上下旋转画面的角度，越大说明旋转的角度越大

				// controls = new THREE.TrackballControls( camera );
				// controls.rotateSpeed = 1.0;
				// controls.zoomSpeed = 1.2;
				// controls.panSpeed = 0.8;
				// controls.noZoom = false;
				// controls.noPan = false;
				// controls.staticMoving = true;
				// controls.dynamicDampingFactor = 0.3;
				// controls.keys = [ 65, 83, 68 ];
				// controls.addEventListener( 'change', render );

				scene.add( new THREE.AmbientLight( 0x222222 ) );
				// light

				var light = new THREE.PointLight( 0xffffff, 1 );
				camera.add( light );

				var map_data = JSON.parse('{{ geo | tojson | safe}}');

				var river_vertices = map_data.river_vertices;
				var river_faces = map_data.river_faces;
				var river_geomotry = new THREE.Geometry();
				for(var i = 0; i < river_vertices.length; i++)
                {
                   var point = river_vertices[i];
                   var p = new THREE.Vector3(parseFloat(point[0]), parseFloat(point[1]), parseFloat(point[2]));
                   river_geomotry.vertices.push(p);
                }
                for(var i = 0; i < river_faces.length; i++)
                {
                   var face = river_faces[i];
                   var f = new THREE.Face3(parseInt(face[0]), parseInt(face[1]), parseInt(face[2]));
                   river_geomotry.faces.push(f);
                }
                var river_material = new THREE.MeshBasicMaterial({color: 0x84bfe8});
				var river_mesh = new THREE.Mesh(river_geomotry, river_material);
				scene.add(river_mesh);
				console.log('river added');

				var city_vertices = map_data.city_vertices;
				var city_faces = map_data.city_faces;
				var city_geomotry = new THREE.Geometry();
				for(var i = 0; i < city_vertices.length; i++)
                {
                   var point = city_vertices[i];
                   var p = new THREE.Vector3(parseFloat(point[0]), parseFloat(point[1]), parseFloat(point[2]));
                   city_geomotry.vertices.push(p);
                }
                for(var i = 0; i < city_faces.length; i++)
                {
                   var face = city_faces[i];
                   var f = new THREE.Face3(parseInt(face[0]), parseInt(face[1]), parseInt(face[2]));
                   city_geomotry.faces.push(f);
                }
                console.log(city_geomotry.vertices.length, city_geomotry.faces.length);
                var city_material = new THREE.MeshBasicMaterial({color: 0x4a708b});
				var city_mesh = new THREE.Mesh(city_geomotry, city_material);
				scene.add(city_mesh);
				console.log('city added');

				var shelter_vertices = map_data.shelter_vertices;
				var shelter_faces = map_data.shelter_faces;
				var shelter_geomotry = new THREE.Geometry();
				for(var i = 0; i < shelter_vertices.length; i++)
                {
                   var point = shelter_vertices[i];
                   var p = new THREE.Vector3(parseFloat(point[0]), parseFloat(point[1]), parseFloat(point[2]));
                   shelter_geomotry.vertices.push(p);
                }
                for(var i = 0; i < shelter_faces.length; i++)
                {
                   var face = shelter_faces[i];
                   var f = new THREE.Face3(parseInt(face[0]), parseInt(face[1]), parseInt(face[2]));
                   shelter_geomotry.faces.push(f);
                }
                console.log(shelter_geomotry.vertices.length, shelter_geomotry.faces.length);
                var shelter_material = new THREE.MeshBasicMaterial({color: 0x00fff0});
				var shelter_mesh = new THREE.Mesh(shelter_geomotry, shelter_material);
				scene.add(shelter_mesh);
				console.log('shelter added');


				camera.position.set(0, 1700, 1500);
				camera.lookAt(0, 1700, 0);

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function onWindowResize() {
				width = document.getElementById('canvas3d').clientWidth;
				height = document.getElementById('canvas3d').clientHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				// controls.handleResize();
				renderer.setSize( width, height );

			}

			function animate() {

				requestAnimationFrame( animate );
				// controls.update();

				// group.rotation.y += 0.005;

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}


		</script>
		<style>
			body {
				font-family: Monospace;
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				color: #fff;
				top: 0px;
				width: 100%;
				padding: 5px;
				text-align:center;
			}
			#canvas3d {
				border: none;
	            cursor: move;
	            width: 1400px;
	            height: 800px;
	            background-color: #EEEEEE;
			}
			a {
				color: #fff;
			}
		</style>
<!-- 		<style type="text/css">
            div#canvas3d{
                  border: none;
                  cursor: move;
                  width: 1400px;
                  height: 800px;
                  background-color: #EEEEEE;
                }
        </style> -->

	</head>
	<body onload='threeStart();'>

		<div id="info">
			<span style="padding-left:70%">
				<input type="button" value="make" onclick="loadMap();"/>
				<input type="text" id="y_limit" size="10" />
				<input type="text" id="cluster_id" size="10" />
				<input type="button" value="show_lower" onclick="showAgent(true);"/>
				<input type="button" value="show_upper" onclick="showAgent(false);"/>
			</span>
		</div>
		<div id="canvas3d"></div>

		
		

	</body>
</html>
